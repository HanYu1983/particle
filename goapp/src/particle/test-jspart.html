<html>
	<body>
		<img id='logo' src='../common/images/logo.jpg'>
		<div id='webgl'></div>
		<script src="../common/js/lib/jquery/jquery-1.11.1.min.js"></script>	
		<script src='../common/js/lib/three.min.js'></script>
		<script src='../common/js/lib/underscore/underscore-min.js'></script>
		<script src='js/particle.js'></script>
		<script>
		
		
		function drawer( elem ){
			var logo = $('#logo')[0]
			var tex = new THREE.Texture(logo)
			// 需要這行，不然畫不出材質
			tex.needsUpdate = true
			
			var useWebgl = true
			var w = 1200.0
			var h = 627.0
			var scene = new THREE.Scene
			var camera = new THREE.OrthographicCamera( w/-2, w/2, h/2, h/-2, -500, 1000 )
			camera.position.set( 0, 0, 200 )
	
			var renderer = useWebgl ? new THREE.WebGLRenderer({antialias: true}) : new THREE.CanvasRenderer({antialias: true})
			
			renderer.setSize( w, h )
			renderer.setClearColor( 0, 1 );
			
			$(renderer.domElement).appendTo( elem )
			
			var objs = {}
			var dirtyTag = {}
			
			function createObject( scene, key, part ){
				var obj = objs[key]
				if( obj == null ){
					
					var material = new THREE.MeshBasicMaterial( { map:null, color: 0x33aa55 } );
					// 加上transparent:true才會有png的透明效果, 也才有blending效果
					material.transparent = true;
					
					material.blending = THREE[ 'CustomBlending' ];

					material.blendSrc = THREE[ 'OneFactor' ];
					material.blendDst = THREE[ 'OneFactor' ];
					material.blendEquation = THREE.AddEquation;

					material.blendSrcAlpha = THREE[ 'OneFactor' ];
					material.blendDstAlpha = THREE[ 'OneFactor' ];
					material.blendEquationAlpha = THREE.AddEquation;
					
					obj = new THREE.Mesh(new THREE.PlaneBufferGeometry(1, 1), material)
					objs[key] = obj
					scene.add( obj )
				}
				
				return obj
			}
			
			function removeObject( key ){
				var obj = objs[key]
				if( obj != null ){
					scene.remove( obj )
					//不必刪除，用來重用
					//delete objs[key]
				}
			}
			
			function markDirty( key ){
				dirtyTag[key] = true
			}
			
			function clearDirtyTag(){
				for( var k in dirtyTag ){
					dirtyTag[k] = false
				}
			}
			
			function useDirty( fn ){
				for( var k in dirtyTag ){
					if( dirtyTag[k] == false ){
						delete dirtyTag[k]
						fn(k)
					}
				}
			}
			
			return function( ctx ){
				
				clearDirtyTag()
				
				var parts = ctx.parts
				for( var idx in parts ){
					var part = parts[idx]
					var obj = createObject( scene, part.id, part )
					obj.material.map = tex
					obj.material.color.setHex(parseInt( part.color.substr(1), 16 ))
					obj.position.set( part.pos[0], part.pos[1], 0 )
					obj.rotation.z = part.pos[2]*180/ 3.14
					obj.scale.set( part.size[0], part.size[1], 1 )
					markDirty( part.id )
				}
				
				useDirty( function( key ){
					removeObject( key )
				})
				
				renderer.render( scene, camera )
			}
		}
		
		var draw = drawer($('#webgl'))
		var pool = particle.pool( 5 )
		var first = particle.initParticle( pool.get(), { 
			vel: [1, 1, 5],
			emit: {
				duration: 0.05,
				force: 100,
				proto: [
					{
						color: '#aabb44',
						lifetime: 3,
						vel: [0, 0, 1]
					}
				]
			},
			formulaList: [
				function(part, lifep){
					return part.pos[0] -= 10
				}
			]
		})
		var ctx = {
			parts: [first]
		}
		setTimeout( function(){
			particle.stepParticles( pool, ctx.parts, 0.1 )
			draw( ctx )
			setTimeout( arguments.callee, 50 )
		}, 1000)
		</script>
	</body>
</html>